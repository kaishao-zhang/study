# java设计模式-单例模式
> 单例设计模式的重点是: <br>
> 1）、私有化构造器。<br>
> 2）、类的内部创建对象。<br>
> 3）、向外暴漏一个静态的公共方法。<br>
> 4）、代码实现。
* 饿汉式
  * 静态变量方式（Demo01）
    >优点：这种写法比较简单，就是在类装载的时候就完成了实例化。避免了线程同步的问题<br>
     缺点：在类装载的时候就完成了实例化，没有达到**Lazy Loading**的效果。如果从始至终从未使用过该实例，则会造成内存的浪费。
  * 静态代码块（Demo02）
    >优点：这种写法比较简单，就是在类装载的时候就完成了实例化。避免了线程同步的问题<br>
    缺点：在类装载的时候就完成了实例化，没有达到**Lazy Loading**的效果。如果从始至终从未使用过该实例，则会造成内存的浪费。
* 懒汉式
  * 线程不安全（Demo03）
    >优点：起到了**Lazy Loading**的效果<br>
    缺点：如果在多线程的下，一个线程进入了`if (null == singleton)`判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时
    便会产生多个实例。所以在多线程的情况下不要使用该代码
  * 线程安全：同步方法（Demo04）
    >优点：解决了线程不安全问题<br>
    缺点：效率太低了，每个线程在想获得实例时候，执行`getInstance()`方法都要进行同步。而其实这个方法只执行一些词实例化代码就够了，后面的
    想获得该实例直接*return*即可。方法进行同步效率太低
  * 线程安全：双重检测锁（Demo05）
    >优点：**Double-Check**进行了两次`if (null == singleton)`检查，保证了线程安全，同时，实例化代码只用了一次，后面再次访问时，直接
    返回实例化对象，避免了反复进行创建。
  * 静态内部类（Demo06）
    >优点：这种方式采用了类装载的机制来保证初始化实例时只有一个线程，静态内部类的方式在`Singleton`类装载时并不会被立即实例化，而是在需
    要实例化时，调用`getInstance`方法，才会装载`SingletonInstance`类，从而完成实例化。类的静态属性只会在第一次加载类的时候初始化，所以
    `JVM`帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
* 枚举类（Demo07）
  > 优点：枚举类型是线程安全的，并且只会装载一次，枚举类型是所用单例实现中唯一一种不会被破坏的单例实现，可以天然的防反射攻击，防序列化与反
  序列化破坏。